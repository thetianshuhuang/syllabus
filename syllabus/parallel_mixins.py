
"""Task-wrapped map-reduce implementations"""

from .threadpool import Pool


class ParallelMixin:

    def pool(self, *args, process=False, **kwargs):
        """Run Map-Reduce pool

        Parameters
        ----------
        process : bool
            If True, a process pool is used; if false, a thread pool is used
        """

        if process:
            return self.__proc_pool(*args, **kwargs)
        else:
            return self.__thread_pool(*args, **kwargs)

    def __thread_pool(
            self, target, args, shared_args=[], shared_kwargs={},
            reducer=None, recursive=True, split=2,
            name='Child Task Thread', threads=None):
        """Run a task-wrapped thread pool

        Parameters
        ----------
        target : (argument, *args, task=Task, **kwargs) -> result
            Function to run on each argument; shared_args should be set as
            globals by shared_init.
        args : T[]
            List of parameters (arbitrary type)
        shared_args : {arbitrary type}
            Shared arguments to pass to each function call
        shared_kwargs : {arbitrary type}
            Shared keyword arguments to pass to each function
        reducer : result[], task=subtask -> result
            Combines multiple results into a single object.
        recursive : bool
            If True, the reducer is run recursively with multiple processes
            to finish in O(log(n)) time.
        split : int
            Number of results to assign to each reduce iteration.
        name : str
            Name of the child processes to create
        threads : int
            Number of threads to use

        Returns
        -------
        Arbitrary type or T[]
            List of reduced results generated by the provided reducer; if
            no reducer is provided, the results are returned as a list.
        """

        self.log('Set up thread map')
        p = Pool(threads=threads)
        self.log(
            'Started thread pool map with {i} processes'
            .format(i=threads))
        results = p.map(
            target, args, **shared_args,
            task=self, name=name, **shared_kwargs)
        self.log('Reducing results...')

        if reducer is not None:
            results = reducer(results)  # todo: handle recursive

        return results

    def __proc_pool(
            self, target, args,
            shared_kwargs=None, shared_init=None,
            reducer=None, recursive=True, split=2,
            name='Child Task Process', cores=None):
        """Run a task-wrapped process pool

        Parameters
        ----------
        target : [arg, task] -> result
            Function to run on each argument; shared_args should be set as
            globals by shared_init.
        args : T[]
            List of parameters (arbitrary type)
        shared_kwargs : {arbitrary type}
            Shared arguments to pass to each process
        shared_init : shared_args -> void
            Set globals in order to handle shared arg inheritance
        reducer : result[], task=subtask -> result
            Combines multiple results into a single object.
        recursive : bool
            If True, the reducer is run recursively with multiple processes
            to finish in O(log(n)) time.
        split : int
            Number of results to assign to each reduce iteration.
        name : str
            Name of the child processes to create
        cores : int
            Number of processes to use

        Returns
        -------
        Arbitrary type or T[]
            List of reduced results generated by the provided reducer; if
            no reducer is provided, the results are returned as a list.
        """

        if shared_kwargs is not None and shared_init is not None:
            self.log('Set up process map with initializer')
            p = Pool(
                processes=cores,
                intitializer=shared_init,
                initargs=shared_kwargs)

        else:
            self.log('Set up process map with no initializer')
            p = Pool(processes=cores)

        # Task generator expression
        genexpr = ([arg, self.subtask(name=name)] for arg in args)

        self.log(
            'Started process pool map with {i} processes'
            .format(i=cores))
        results = p.map(target, genexpr)
        self.log('Reducing results...')

        if reducer is not None:
            results = reducer(results)  # todo: handle recursive

        return results
